#!/usr/bin/env python2
# This file is covered by LGPLv2.1 or later, read LICENSE for details.

import locale
# We shall always behave the same, regardless of locale
locale.setlocale(locale.LC_ALL, 'en_US')

import sys

try:
    import argparse
except ImportError as e:
    sys.stderr.write("Can't import argparse. Please use Python 2.7+ or install argparse separately.\n")
    sys.exit(1)

import string
import os.path
import shutil
import datetime
import tempfile
import subprocess

if subprocess.call(["rpmbuild", "--version"], stdout = sys.stdout, stderr = sys.stderr) != 0:
    sys.stderr.write("Could not execute `rpmbuild --version`. "
        "Please make sure it's installed (often packaged as 'rpm-build').\n")
    sys.exit(1)

def get_rpmbuild_paths():
    sources = subprocess.check_output(["rpm", "--eval", "%{_sourcedir}"]).strip()

    if not os.path.exists(sources):
        if subprocess.call(["rpmdev-setuptree"], stdout = sys.stdout, stderr = sys.stderr) != 0:
            sys.stderr.write("Failed to setup rpmbuild tree. Please make sure you have rpmdev-setuptree "
                "installed, or set it up manually. The SOURCES directory (%%{_sourcedir}) was expected at "
                "'%s'\n" % (sources))
            sys.exit(1)

    rpm = subprocess.check_output(["rpm", "--eval", "%{_rpmdir}"]).strip()
    srpm = subprocess.check_output(["rpm", "--eval", "%{_srcrpmdir}"]).strip()

    if not os.path.exists(rpm) or not os.path.exists(srpm):
        sys.stderr.write("The SOURCES rpmbuild directory exists but RPM or SRPM do not. Please make "
            "sure your rpmbuild tree is setup correctly. Delete it and it will be created automatically.\n")

    return sources, rpm, srpm

def copy_sources_to_rpmbuild(rpmbuild_sources_path, files):
    for f in files:
        shutil.copyfile(f.name, "%s/%s" % (rpmbuild_sources_path, os.path.basename(f.name)))

def make_sources_list(files):
    ret = ""

    i = 0
    for f in files:
        ret += "Source%i: %s\n" % (i, os.path.basename(f.name))
        i += 1

    return ret

def make_installer(scap_location, files):
    prepper = ""
    installer = ""
    installed_files = ""

    i = 0
    for f in files:
        prepper += "cp %%SOURCE%i .\n" % (i)
        i += 1

        installer += "cp %s $RPM_BUILD_ROOT/%s/%%{name}/\n" % (os.path.basename(f.name), scap_location)
        installed_files += "%s/%%{name}/%s\n" % (scap_location, os.path.basename(f.name))

    return prepper, installer, installed_files

def create_spec(template_path, name,
        version, release, summary, license,
        scap_location, files,
        target_file):
    template = None

    with open(template_path) as f:
        template = string.Template(f.read())

    sources_list = make_sources_list(files)
    prepper, installer, installed_files = make_installer(scap_location, files)

    spec_source = template.safe_substitute(
        __package_name = name,

        __package_version = version,
        __package_release = release,
        __package_summary = summary,
        __package_license = license,

        __package_scap_location = scap_location,

        __package_sources = sources_list,
        __package_openscap_version = "0.9.12", # FIXME
        __package_prepper = prepper,
        __package_installer = installer,
        __package_installed_files = installed_files,
        __changelog_date = datetime.date.today().strftime("%a %b %d %Y")
    )

    target_file.write(spec_source)

def main():
    parser = argparse.ArgumentParser(
        description = "Takes given SCAP input(s) and makes an RPM package that contains them. "
                      "The result RPM can be installed using # yum install ./package-name-1-1.rpm "
                      "which will put the contents into /usr/share/scap. No dependency on openscap "
                      "or scap-workbench is enforced in the output package so you can use any "
                      "SCAP-capable scanner to evaluate the content.")

    # we choose name automatically if its missing
    parser.add_argument("--pkg-name", dest = "pkg_name", default = None,
            help = "Name of the RPM package, if none is provided the basename of the first SCAP input is used. Ex.: xyz-security-guide")
    parser.add_argument("--pkg-version", dest = "pkg_version", default = "1")
    parser.add_argument("--pkg-release", dest = "pkg_release", default = "1")
    parser.add_argument("--pkg-summary", dest = "pkg_summary", default = "stub",
        help = "Optional short description of the package.")
    parser.add_argument("--pkg-license", dest = "pkg_license", default = "Unknown",
        help = "Short name of the license that you want to publish the package under. Ex.: GPLv2+, BSD, ...")

    parser.add_argument("--pkg-scap-location", dest = "pkg_scap_location", default = "%{_datadir}/scap",
        help = "Folder where SCAP files are supposed to be installed. Each package will have its own folder "
               "inside this folder. RPM variables can be used and will be expanded as usual. It is "
               "recommended to keep the default settings.")

    parser.add_argument("--rpm-destination", dest = "rpm_destination", default = ".",
        help = "The folder (absolute or relative to CWD) where the result RPM shall be saved.")
    parser.add_argument("--srpm-destination", dest = "srpm_destination", default = ".",
        help = "The folder (absolute or relative to CWD) where the result SRPM shall be saved.")
    parser.add_argument("files", metavar = "FILE", nargs = '+', type = argparse.FileType('r'),
        help = "List of files that should be put into the result package. "
               "These should be SCAP XML files but such requirement is not enforced.")

    args = parser.parse_args()

    rpmbuild_sources_path, rpmbuild_rpm_path, rpmbuild_srpm_path = get_rpmbuild_paths()

    copy_sources_to_rpmbuild(rpmbuild_sources_path, args.files)

    name = args.pkg_name
    if name is None:
        name, _ = os.path.splitext(os.path.basename(args.files[0].name))

    temp_dir = tempfile.mkdtemp()
    spec_file = open("%s/%s.spec" % (temp_dir, name), "w")
    create_spec("templates/package.spec",
        name,
        args.pkg_version, args.pkg_release, args.pkg_summary, args.pkg_license,
        args.pkg_scap_location, args.files,
        spec_file)
    spec_file_path = spec_file.name
    spec_file.close()

    assert(subprocess.call(["rpmbuild", "-ba", spec_file_path], stdout = sys.stdout) == 0)

    rpm_basename = "%s-%s-%s.noarch.rpm" % (name, args.pkg_version, args.pkg_release)
    srpm_basename = "%s-%s-%s.src.rpm" % (name, args.pkg_version, args.pkg_release)

    shutil.copy("%s/noarch/%s" % (rpmbuild_rpm_path, rpm_basename), args.rpm_destination)
    shutil.copy("%s/%s" % (rpmbuild_srpm_path, srpm_basename), args.srpm_destination)

    print("")
    print("Resulting RPM:\t'%s'" % (os.path.join(args.rpm_destination, rpm_basename)))
    print("Resulting SRPM:\t'%s'" % (os.path.join(args.srpm_destination, srpm_basename)))
    print("")
    print("Finished!")
    sys.exit(0)

if __name__ == "__main__":
    main()
